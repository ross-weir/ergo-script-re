use ergotree_ir::mir::expr::Expr;

use crate::{
    error::PseudoCodeError,
    visitor::{Element, Visitor},
    GeneratorContext, PseudoCode,
};

impl PseudoCode for Expr {
    fn pseudo_code<'a>(
        &'a self,
        ctx: &mut GeneratorContext,
        stack: &mut Vec<&'a Expr>,
    ) -> Result<String, PseudoCodeError> {
        stack.push(self);

        let v = match self {
            Expr::Append(_) => todo!(),
            Expr::Const(e) => e.pseudo_code(ctx, stack),
            Expr::ConstPlaceholder(e) => e.pseudo_code(ctx, stack),
            Expr::SubstConstants(_) => todo!(),
            Expr::ByteArrayToLong(_) => todo!(),
            Expr::ByteArrayToBigInt(_) => todo!(),
            Expr::LongToByteArray(_) => todo!(),
            Expr::Collection(e) => e.pseudo_code(ctx, stack),
            Expr::Tuple(_) => todo!(),
            Expr::CalcBlake2b256(_) => todo!(),
            Expr::CalcSha256(_) => todo!(),
            Expr::Context => todo!(),
            Expr::Global => todo!(),
            Expr::GlobalVars(e) => e.pseudo_code(ctx, stack),
            Expr::FuncValue(e) => e.pseudo_code(ctx, stack),
            Expr::Apply(_) => todo!(),
            Expr::MethodCall(_) => todo!(),
            Expr::ProperyCall(e) => e.pseudo_code(ctx, stack),
            Expr::BlockValue(e) => e.pseudo_code(ctx, stack),
            Expr::ValDef(e) => e.pseudo_code(ctx, stack),
            Expr::ValUse(e) => e.pseudo_code(ctx, stack),
            Expr::If(e) => e.pseudo_code(ctx, stack),
            Expr::BinOp(e) => e.pseudo_code(ctx, stack),
            Expr::And(_) => todo!(),
            Expr::Or(_) => todo!(),
            Expr::Xor(_) => todo!(),
            Expr::Atleast(e) => e.pseudo_code(ctx, stack),
            Expr::LogicalNot(_) => todo!(),
            Expr::Negation(_) => todo!(),
            Expr::BitInversion(_) => todo!(),
            Expr::OptionGet(e) => e.pseudo_code(ctx, stack),
            Expr::OptionIsDefined(_) => todo!(),
            Expr::OptionGetOrElse(_) => todo!(),
            Expr::ExtractAmount(e) => e.pseudo_code(ctx, stack),
            Expr::ExtractRegisterAs(e) => e.pseudo_code(ctx, stack),
            Expr::ExtractBytes(_) => todo!(),
            Expr::ExtractBytesWithNoRef(_) => todo!(),
            Expr::ExtractScriptBytes(e) => e.pseudo_code(ctx, stack),
            Expr::ExtractCreationInfo(_) => todo!(),
            Expr::ExtractId(e) => e.pseudo_code(ctx, stack),
            Expr::ByIndex(e) => e.pseudo_code(ctx, stack),
            Expr::SizeOf(e) => e.pseudo_code(ctx, stack),
            Expr::Slice(_) => todo!(),
            Expr::Fold(_) => todo!(),
            Expr::Map(_) => todo!(),
            Expr::Filter(e) => e.pseudo_code(ctx, stack),
            Expr::Exists(_) => todo!(),
            Expr::ForAll(_) => todo!(),
            Expr::SelectField(e) => e.pseudo_code(ctx, stack),
            Expr::BoolToSigmaProp(e) => e.pseudo_code(ctx, stack),
            Expr::Upcast(_) => todo!(),
            Expr::Downcast(_) => todo!(),
            Expr::CreateProveDlog(_) => todo!(),
            Expr::CreateProveDhTuple(_) => todo!(),
            Expr::SigmaPropBytes(_) => todo!(),
            Expr::DecodePoint(_) => todo!(),
            Expr::SigmaAnd(_) => todo!(),
            Expr::SigmaOr(_) => todo!(),
            Expr::GetVar(_) => todo!(),
            Expr::DeserializeRegister(_) => todo!(),
            Expr::DeserializeContext(_) => todo!(),
            Expr::MultiplyGroup(_) => todo!(),
            Expr::Exponentiate(_) => todo!(),
            Expr::XorOf(_) => todo!(),
            Expr::TreeLookup(_) => todo!(),
            Expr::CreateAvlTree(_) => todo!(),
        };

        stack.pop();

        v
    }
}

impl Element for Expr {
    fn accept<T: Visitor>(&self, visitor: &mut T) {
        match self {
            Expr::Append(_) => todo!(),
            Expr::Const(_) => todo!(),
            Expr::ConstPlaceholder(_) => todo!(),
            Expr::SubstConstants(_) => todo!(),
            Expr::ByteArrayToLong(_) => todo!(),
            Expr::ByteArrayToBigInt(_) => todo!(),
            Expr::LongToByteArray(_) => todo!(),
            Expr::Collection(_) => todo!(),
            Expr::Tuple(_) => todo!(),
            Expr::CalcBlake2b256(_) => todo!(),
            Expr::CalcSha256(_) => todo!(),
            Expr::Context => todo!(),
            Expr::Global => todo!(),
            Expr::GlobalVars(e) => e.accept(visitor),
            Expr::FuncValue(e) => e.accept(visitor),
            Expr::Apply(_) => todo!(),
            Expr::MethodCall(_) => todo!(),
            Expr::ProperyCall(e) => e.accept(visitor),
            Expr::BlockValue(e) => e.accept(visitor),
            Expr::ValDef(e) => e.accept(visitor),
            Expr::ValUse(e) => e.accept(visitor),
            Expr::If(e) => e.accept(visitor),
            Expr::BinOp(e) => e.accept(visitor),
            Expr::And(_) => todo!(),
            Expr::Or(_) => todo!(),
            Expr::Xor(_) => todo!(),
            Expr::Atleast(e) => e.accept(visitor),
            Expr::LogicalNot(_) => todo!(),
            Expr::Negation(_) => todo!(),
            Expr::BitInversion(_) => todo!(),
            Expr::OptionGet(e) => e.accept(visitor),
            Expr::OptionIsDefined(_) => todo!(),
            Expr::OptionGetOrElse(_) => todo!(),
            Expr::ExtractAmount(e) => e.accept(visitor),
            Expr::ExtractRegisterAs(e) => e.accept(visitor),
            Expr::ExtractBytes(_) => todo!(),
            Expr::ExtractBytesWithNoRef(_) => todo!(),
            Expr::ExtractScriptBytes(e) => e.accept(visitor),
            Expr::ExtractCreationInfo(_) => todo!(),
            Expr::ExtractId(e) => e.accept(visitor),
            Expr::ByIndex(e) => e.accept(visitor),
            Expr::SizeOf(e) => e.accept(visitor),
            Expr::Slice(_) => todo!(),
            Expr::Fold(_) => todo!(),
            Expr::Map(_) => todo!(),
            Expr::Filter(e) => e.accept(visitor),
            Expr::Exists(_) => todo!(),
            Expr::ForAll(_) => todo!(),
            Expr::SelectField(e) => e.accept(visitor),
            Expr::BoolToSigmaProp(e) => e.accept(visitor),
            Expr::Upcast(_) => todo!(),
            Expr::Downcast(_) => todo!(),
            Expr::CreateProveDlog(_) => todo!(),
            Expr::CreateProveDhTuple(_) => todo!(),
            Expr::SigmaPropBytes(_) => todo!(),
            Expr::DecodePoint(_) => todo!(),
            Expr::SigmaAnd(_) => todo!(),
            Expr::SigmaOr(_) => todo!(),
            Expr::GetVar(_) => todo!(),
            Expr::DeserializeRegister(_) => todo!(),
            Expr::DeserializeContext(_) => todo!(),
            Expr::MultiplyGroup(_) => todo!(),
            Expr::Exponentiate(_) => todo!(),
            Expr::XorOf(_) => todo!(),
            Expr::TreeLookup(_) => todo!(),
            Expr::CreateAvlTree(_) => todo!(),
        }
    }
}
